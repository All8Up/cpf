use ast::{Data, NodeRef};

grammar;

Identifier: String =
{
	<s:r"[_a-zA-Z][_a-zA-Z0-9]+"> => s.to_string()
};

QualifiedIdentifier: String =
{
	Identifier,
	<l:QualifiedIdentifier> "::" <r:Identifier> => {l + "::" + &r}
};

StringLiteral: String =
{
	<s:r"'.*'"> => s.to_string()
};

Access: () =
{
	"in",
	"out",
	"in_out"
};

Types: () =
{
	"u8",
	"i8",
	"u16",
	"i16",
	"u32",
	"i32",
	"u64",
	"i64",
	"f32",
	"f64",
	"char",
	"wchar",
	"void",
	"result"
};

Success: () =
{
	"success"
};
Failure: () =
{
	"failure"
};

ClassID: () = {"class_id"};
InterfaceID: () = {"interface_id"};
Import: () = {"import"};
Namespace: () = {"namespace"};
Interface: () = {"interface"};

// ------

ClassIDStmt: NodeRef<Data> =
{
	ClassID <n:Identifier> "(" <v:StringLiteral> ")" ";" =>
		NodeRef::new(Data::ClassID {name: n, cid: v})
};

InterfaceIDStmt: NodeRef<Data> =
{
	InterfaceID <n:Identifier> "(" <v:StringLiteral> ")" ";" =>
		NodeRef::new(Data::InterfaceID {name: n, iid: v})
};

ImportStmt: NodeRef<Data> =
{
	Import <n:Identifier> =>
		NodeRef::new(Data::Import {name: n})
};

NamespaceStmt: NodeRef<Data> =
{
	// Handle empty namespaces.
	Namespace <n:Identifier> "{" "}" =>
		NodeRef::new(Data::Namespace {name: n})
	,
	Namespace <n:Identifier> "{" <i:NamespaceBlock> "}" =>
	{
		let n = NodeRef::new(Data::Namespace {name: n});
		n.append(i);
		n
	}
};

InterfaceStmts: NodeRef<Data> =
{
	InterfaceIDStmt
};

InterfaceBlock: NodeRef<Data> =
{
	"{" "}" => NodeRef::new(Data::Block),
	"{" InterfaceStmts "}" => NodeRef::new(Data::Block)
};

InterfaceStmt: NodeRef<Data> =
{
	Interface <n:Identifier> ";" => NodeRef::new(Data::FwdInterface {name: n}),
	Interface <n:Identifier> <b:InterfaceBlock> =>
	{
		let node = NodeRef::new(Data::Interface {name: n, base: None});
		node.append(b);
		node
	},
	Interface <n:Identifier> ":" <q:QualifiedIdentifier> <b:InterfaceBlock> =>
	{
		let node = NodeRef::new(Data::Interface {name: n, base: Some(q)});
		node.append(b);
		node
	}
};

// --- Global statements ---

GlobalScopeStmt: NodeRef<Data> =
{
	ImportStmt,
	InterfaceStmt,
	NamespaceStmt,
	ClassIDStmt
};

NamespaceScopeStmt: NodeRef<Data> =
{
	NamespaceStmt,
	InterfaceStmt,
	ClassIDStmt
};

NamespaceBlock: NodeRef<Data> =
{
	<ns:NamespaceScopeStmt> =>
	{
		let n = NodeRef::new(Data::Block);
		n.append(ns);
		n
	},
	<l:NamespaceBlock> <r:NamespaceScopeStmt> =>
	{
		l.append(r);
		l
	}
};

// Returns a block of all global statments.
GlobalBlock: NodeRef<Data> =
{
	<s:GlobalScopeStmt> =>
	{
		let n = NodeRef::new(Data::Block);
		n.append(s);
		n
	},
	<l:GlobalBlock> <r:GlobalScopeStmt> =>
	{
		l.append(r);
		l
	}
};

pub IDL: NodeRef<Data> =
{
	GlobalBlock
};
