use ast::*;

grammar;

Identifier: String =
{
	ID => <>.to_string()
};

BinaryChar: i32 =
{
	"0" => 0,
	"1" => 1
};

QualifiedIdentifier: String =
{
	Identifier,
	<l:QualifiedIdentifier> ":" ":" <r:Identifier> => {l + "::" + &r}
};

//
Access: DirectionAnnotation =
{
	In => DirectionAnnotation::In,
	Out => DirectionAnnotation::Out
};

PrimitiveIntegralType: DataType =
{
	U8 => DataType::U8,
	I8 => DataType::I8,
	U16 => DataType::U16,
	I16 => DataType::I16,
	U32 => DataType::U32,
	I32 => DataType::I32,
	U64 => DataType::U64,
	I64 => DataType::I64,
	SizeT => DataType::SizeT
};

PrimitiveFloatType: DataType =
{
	F32 => DataType::F32,
	F64 => DataType::F64
};

PrimitiveCharType: DataType =
{
	Char => DataType::Char,
	WChar => DataType::WChar
};

AnyPrimitiveType: DataType =
{
	PrimitiveIntegralType,
	PrimitiveFloatType,
	PrimitiveCharType
};

CompoundType: DataType =
{
	Result => DataType::Result,
	Identifier => DataType::NamedType {name: <>}
};

Types: DataType =
{
	AnyPrimitiveType,
	CompoundType,
	Void => DataType::Void
};

TypeQualifier: TypeQualifier =
{
	Const => TypeQualifier::Const
};

// Type handling needs:
//	[in] u8 c
//	[in, out] u8* n
//	[in] const u16* p
//	[out] iTest** iface

TypeAnnotation: Annotation =
{
	"[" <l:Access> <r:("," <Access>)?> "]" =>
		Annotation {left: Some(l), right: r}
};

PointerDef: u32 =
{
	"*" => 1,
	<p:PointerDef> "*" => p+1
};

ModifiedType: ModifiedType =
{
	<q:(TypeQualifier)?> <t:Types> =>
		ModifiedType {qualifier: q, data_type: t, indirection_count: 0},
	<q:(TypeQualifier)?> <t:Types> <p:PointerDef> =>
		ModifiedType {qualifier: q, data_type: t, indirection_count: p}
};

TypeDecl: TypeDecl =
{
	<a:(TypeAnnotation)?> <t:ModifiedType> =>
		TypeDecl {annotation: a, data_type: t}
};

// Constant initializers.
ConstDecl: ASTRef =
{
	Success <n:Identifier> "=" "{" <ss:DQuotedString> "," <v:DQuotedString> "}" SemiColon =>
		NodeRef::new(Box::new(ResultConst {
			name: n, is_error: false, sub_system: ss[1..ss.len()-1].to_string(), code: v[1..v.len()-1].to_string()
		})),
	Failure <n:Identifier> "=" "{" <ss:DQuotedString> "," <v:DQuotedString> "}" SemiColon =>
		NodeRef::new(Box::new(ResultConst {
			name: n, is_error: true, sub_system: ss[1..ss.len()-1].to_string(), code: v[1..v.len()-1].to_string()
		}))
};

// ------
ParamDecl: Parameter =
{
	<t:TypeDecl> <n:Identifier> =>
		Parameter {name: n, data_type: t}
};

ParamList: ParameterList =
{
	<p:ParamDecl> =>
	{
		let mut param_list = ParameterList::new();
		param_list.push(p);
		param_list
	},
	<l:ParamList> "," <r:ParamDecl> =>
	{
		let mut result = l.clone();
		result.push(r.clone());
		result
	}
};

MethodSignature: InterfaceStatement =
{
	<r:ModifiedType> <n:Identifier> "(" ")" SemiColon =>
		InterfaceStatement::Method {
			name: n.to_string(),
			result_type: r,
			parameters: ParameterList::new()
		},
	<r:ModifiedType> <n:Identifier> "(" <p:ParamList> ")" SemiColon =>
	{
		InterfaceStatement::Method {
			name: n.to_string(),
			result_type: r,
			parameters: p
		}
	}
};

// ------

ClassIDStmt: ASTRef =
{
	ClassID <n:Identifier> "(" <v:SQuotedString> ")" SemiColon =>
		NodeRef::new(Box::new(ClassID {name: n, cid: v.to_string()}))
};

InterfaceIDStmt: InterfaceStatement =
{
	InterfaceID "(" <v:DQuotedString> ")" SemiColon =>
		InterfaceStatement::IID {value: v.to_string()}
};

ImportStmt: ASTRef =
{
	Import <n:DQuotedString> =>
		NodeRef::new(Box::new(Import {name: (n[1..n.len()-1]).to_string()}))
};

InterfaceStmts: InterfaceStatement =
{
	InterfaceIDStmt,
	MethodSignature
};

InterfaceBlock: InterfaceStatements =
{
	<stmt:InterfaceStmts> =>
	{
		let mut s = InterfaceStatements::new();
		s.push(stmt);
		s
	},
	<b:InterfaceBlock> <stmt:InterfaceStmts> =>
	{
		let mut block = b.clone();
		block.push(stmt);
		block
	}
};

InterfaceStmt: ASTRef =
{
	Interface <n:Identifier> SemiColon =>
		NodeRef::new(Box::new(FwdInterface {name: n})),
	Interface <n:Identifier> <q:(":" <QualifiedIdentifier>)?> "{" <b:InterfaceBlock> "}" =>
	{
		NodeRef::new(Box::new(Interface {name: n, base: q, statements: b}))
	}
};

StructStmt: ASTRef =
{
	Struct <n:Identifier> SemiColon => NodeRef::new(Box::new(FwdStruct {name: n}))
};

// --- Global statements ---

GlobalScopeStmt: ASTRef =
{
	ImportStmt,
	InterfaceStmt,
	StructStmt,
	NamespaceStmt,
	ClassIDStmt,
	Comment => NodeRef::new(Box::new(Comment {content: <>.to_string()}))
};

NamespaceScopeStmt: ASTRef =
{
	NamespaceStmt,
	InterfaceStmt,
	StructStmt,
	ClassIDStmt,
	ConstDecl,
	Comment => NodeRef::new(Box::new(Comment {content: <>.to_string()}))
};

NamespaceStmt: ASTRef =
{
	Namespace <n:Identifier> "{" <i:(NamespaceBlock)?> "}" =>
	{
		let nn: ASTRef = NodeRef::new(Box::new(Namespace {name: n}));
		match i
		{
			None => (),
			Some(block) =>
			{
				// TODO: append clears the prev/next sibling before insertion, I want to just 'set' the siblings to be block.
				for node in block.following_siblings()
				{
					nn.append(node);
				}
			}
		}
		nn
	}
};

NamespaceBlock: ASTRef =
{
	<ns:NamespaceScopeStmt> =>
	{
		ns
	},
	<l:NamespaceBlock> <r:NamespaceScopeStmt> =>
	{
		let mut target = l.clone();
		loop
		{
			match target.next_sibling()
			{
				None => {target.insert_after(r); break},
				Some(next) => target = next
			}
		}
		l
	}
};

// Returns a block of all global statments.
GlobalBlock: ASTRef =
{
	<s:GlobalScopeStmt> =>
	{
		s
	},
	<l:GlobalBlock> <r:GlobalScopeStmt> =>
	{
		// TODO: Need an 'append_sibling' as this insert_after is not what we really want.
		// TODO: In general the entire tree interface is non-intuitive and needs a refactor.
		let mut target = l.clone();
		loop
		{
			match target.next_sibling()
			{
				None => {target.insert_after(r); break},
				Some(next) => target = next
			}
		}
		l
	}
};

pub IDL: ASTRef =
{
	GlobalBlock
};


// ----- Lexer precedence.
match {
	"success" => Success,
	"failure" => Failure,
	"class_id" => ClassID,
	"interface_id" => InterfaceID,
	"import" => Import,
	"namespace" => Namespace,
	"interface" => Interface,
	"struct" => Struct,
	"u8" => U8,
	"i8" => I8,
	"u16" => U16,
	"i16" => I16,
	"u32" => U32,
	"i32" => I32,
	"u64" => U64,
	"i64" => I64,
	"f32" => F32,
	"f64" => F64,
	"char" => Char,
	"wchar" => WChar,
	"void" => Void,
	"size_t" => SizeT,
	"result" => Result,
	"const" => Const,
	"in" => In,
	"out" => Out,
	"true" => True,
	"false" => False,
	";" => SemiColon,
	r"[_a-zA-Z][_a-zA-Z0-9]*" => ID
} else {
	"[0-9]" => Digit
} else {
	r#"'[^']*'"# => SQuotedString,
	r#""[^"]*""# => DQuotedString,
	r"/\*[.]*\*/" => Comment,
	_
}
