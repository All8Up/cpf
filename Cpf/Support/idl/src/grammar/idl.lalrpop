use ast::*;

grammar;

Identifier: String =
{
	<s:r"[_a-zA-Z][_a-zA-Z0-9]+"> => s.to_string()
};

QualifiedIdentifier: String =
{
	Identifier,
	<l:QualifiedIdentifier> "::" <r:Identifier> => {l + "::" + &r}
};

SQuotedString: String =
{
	<s:r"'.*'"> => s.to_string()
};

DQuotedString: String =
{
	<s:r#"".*""#> => s.to_string()
};

Success: () = {"success"};
Failure: () = {"failure"};
ClassID: () = {"class_id"};
InterfaceID: () = {"interface_id"};
Import: () = {"import"};
Namespace: () = {"namespace"};
Interface: () = {"interface"};
Struct: () = {"struct"};


//
Access: DirectionAnnotation =
{
	"in" => DirectionAnnotation::In,
	"out" => DirectionAnnotation::Out
};

Types: DataType =
{
	"u8" => DataType::U8,
	"i8" => DataType::I8,
	"u16" => DataType::U16,
	"i16" => DataType::I16,
	"u32" => DataType::U32,
	"i32" => DataType::I32,
	"u64" => DataType::U64,
	"i64" => DataType::I64,
	"f32" => DataType::F32,
	"f64" => DataType::F64,
	"char" => DataType::Char,
	"wchar" => DataType::WChar,
	"void" => DataType::Void,
	"size_t" => DataType::SizeT,
	"result" => DataType::Result
};

TypeQualifier: TypeQualifier =
{
	"const" => TypeQualifier::Const
};

// Type handling needs:
//	[in] u8 c
//	[in, out] u8* n
//	[in] const u16* p
//	[out] iTest** iface

TypeAnnotation: Annotation =
{
	"[" <l:Access> <r:("," <Access>)?> "]" =>
		Annotation {left: Some(l), right: r}
};

PointerDef: u32 =
{
	"*" => 1,
	<p:PointerDef> "*" => p+1
};

ModifiedType: ModifiedType =
{
	<q:(TypeQualifier)?> <t:Types> =>
		ModifiedType {qualifier: q, data_type: t, indirection_count: 0},
	<q:(TypeQualifier)?> <t:Types> <p:PointerDef> =>
		ModifiedType {qualifier: q, data_type: t, indirection_count: p}
};

TypeDecl: TypeDecl =
{
	<a:(TypeAnnotation)?> <t:ModifiedType> =>
		TypeDecl {annotation: a, data_type: t}
};

// ------
ParamDecl: NodeRef<Data> =
{
	<t:TypeDecl> <n:(Identifier)?> =>
		NodeRef::new(Data::ParamDecl {name: n, type_decl: t})
};

ParamList: NodeRef<Data> =
{
	<p:ParamDecl> => p,
	<l:ParamList> "," <r:ParamDecl> =>
		{
			let mut target = l.clone();
			loop
			{
				match target.next_sibling()
				{
					None => {target.insert_after(r); break},
					Some(next) => target = next
				}
			}
			l
		}
};

MemberSignature: NodeRef<Data> =
{
	<r:ModifiedType> <n:Identifier> "(" ")" ";" =>
		NodeRef::new(Data::MemberSignature {name: n.to_string(), result_type: r}),
	<r:ModifiedType> <n:Identifier> "(" <p:ParamList> ")" ";" =>
	{
		let node = NodeRef::new(Data::MemberSignature {name: n.to_string(), result_type: r});
		for nn in p.following_siblings()
		{
			node.append(nn);
		}
		node
	}
};

// ------

ClassIDStmt: NodeRef<Data> =
{
	ClassID <n:Identifier> "(" <v:SQuotedString> ")" ";" =>
		NodeRef::new(Data::ClassID {name: n, cid: v})
};

InterfaceIDStmt: NodeRef<Data> =
{
	InterfaceID <n:Identifier> "(" <v:SQuotedString> ")" ";" =>
		NodeRef::new(Data::InterfaceID {name: n, iid: v})
};

ImportStmt: NodeRef<Data> =
{
	Import <n:DQuotedString> =>
		NodeRef::new(Data::Import {name: n})
};

InterfaceStmts: NodeRef<Data> =
{
	InterfaceIDStmt,
	MemberSignature
};

InterfaceBlock: NodeRef<Data> =
{
	<ns:InterfaceStmts> =>
	{
		ns
	},
	<l:InterfaceBlock> <r:InterfaceStmts> =>
	{
		let mut target = l.clone();
		loop
		{
			match target.next_sibling()
			{
				None => {target.insert_after(r); break},
				Some(next) => target = next
			}
		}
		l
	}
};

InterfaceStmt: NodeRef<Data> =
{
	Interface <n:Identifier> ";" => NodeRef::new(Data::FwdInterface {name: n}),
	Interface <n:Identifier> <q:(":" <QualifiedIdentifier>)?> "{" <b:InterfaceBlock> "}" =>
	{
		let node = NodeRef::new(Data::Interface {name: n, base: q});
		for nn in b.following_siblings()
		{
			node.append(nn);
		}
		node
	}
};

StructStmt: NodeRef<Data> =
{
	Struct <n:Identifier> ";" => NodeRef::new(Data::FwdStruct {name: n})
};

// --- Global statements ---

GlobalScopeStmt: NodeRef<Data> =
{
	ImportStmt,
	InterfaceStmt,
	StructStmt,
	NamespaceStmt,
	ClassIDStmt
};

NamespaceScopeStmt: NodeRef<Data> =
{
	NamespaceStmt,
	InterfaceStmt,
	StructStmt,
	ClassIDStmt
};

NamespaceStmt: NodeRef<Data> =
{
	Namespace <n:Identifier> "{" <i:(NamespaceBlock)?> "}" =>
	{
		let nn = NodeRef::new(Data::Namespace {name: n});
		match i
		{
			None => (),
			Some(block) =>
			{
				// TODO: append clears the prev/next sibling before insertion, I want to just 'set' the siblings to be block.
				for node in block.following_siblings()
				{
					nn.append(node);
				}
			}
		}
		nn
	}
};

NamespaceBlock: NodeRef<Data> =
{
	<ns:NamespaceScopeStmt> =>
	{
		ns
	},
	<l:NamespaceBlock> <r:NamespaceScopeStmt> =>
	{
		let mut target = l.clone();
		loop
		{
			match target.next_sibling()
			{
				None => {target.insert_after(r); break},
				Some(next) => target = next
			}
		}
		l
	}
};

// Returns a block of all global statments.
GlobalBlock: NodeRef<Data> =
{
	<s:GlobalScopeStmt> =>
	{
		s
	},
	<l:GlobalBlock> <r:GlobalScopeStmt> =>
	{
		// TODO: Need an 'append_sibling' as this insert_after is not what we really want.
		// TODO: In general the entire tree interface is non-intuitive and needs a refactor.
		let mut target = l.clone();
		loop
		{
			match target.next_sibling()
			{
				None => {target.insert_after(r); break},
				Some(next) => target = next
			}
		}
		l
	}
};

pub IDL: NodeRef<Data> =
{
	GlobalBlock
};
